Синаксис SQL:
1. DDL (Data Definition Language) - определение данных (создать бд, удалить бд,
создать таблицу, удалить таблицу и прочее);

2. DML (Data Manipulation Language) - взаимодействие с таблицами (вставка данных в таблицу, выбор данных из таблицы,
обновление данных в таблице, удаление данных из таблицы);

3. DCL (Data Control Language) - администрирование БД (создание пользователей, назначение прав и прочее).

Создание нового пользователя:
CREATE USER 'user'@'localhost' IDENTIFIED BY 'user';

Предоставление всех прав пользования таблицей:
GRANT ALL ON *.* TO 'user'@'localhost';

DDL
Создать базу данных:
CREATE DATABASE test;

Удалить базу данных:
DROP DATABASE test;

выбор базы данных (для консоли):
USE test;

InnoDB (поодерживает индексы, связи, направлен на выбор данных, быстрое извлечение),
MYISAM (оптимизирован под добавление и изменение данных, но нет поддержки внешних ключей),
Arhive (не поддерживает индексов и транзакций, но используется для редко используемых данных),
Memory (хранение данных в оперативной памяти сервера, но возможна потеря данных),
Blackhole (не хранит данные, данные сразу уничтожаются).

Создание таблицы:

CREATE TABLE IF NOT EXISTS name_table(
	`id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
	`login` VARCHAR(50) NOT NULL,
	`age` INT NOT NULL
) ENGINE=InnoDB

Вставка
INSERT INTO name_table(login, age) VALUES('qwe', 25);

Обновление записи:
UPDATE name_table SET login='newLogin' WHERE id = 2;

Выбор записи:
SELECT имена_столбцов FROM имя_таблицы WHERE условие

SELECT * FROM name_table;
SELECT login FROM name_table;
SELECT login,age FROM name_table;
SELECT * FROM name_table WHERE age > 18;
SELECT * FROM name_table WHERE id = 3;
SELECT * FROM name_table WHERE age BETWEEN 18 AND 45;
SELECT * FROM name_table WHERE age > 18 LIMIT 3;

SELECT * FROM name_table WHERE login LIKE 'a%'; - логин должен начинаться с а, далее - что угодно;
SELECT * FROM name_table WHERE login LIKE '%e'; - логин начинается с чего угодно, в конце - е;
SELECT * FROM name_table WHERE login LIKE '%b%'; - логин содержит b;
SELECT * FROM name_table WHERE login LIKE '_a%'; - a будет на второй позиции;

Объединение условий: AND OR NOT
SELECT * FROM name_table WHERE условие1 AND условие2 и т.д.
SELECT * FROM name_table WHERE условие1 OR условие2 и т.д.
SELECT * FROM name_table WHERE NOT условие1

Удаление записи:
DELETE FROM name_table WHERE id = 5;

show databases - отобразить все БД сервера.

Продолжение (от 14.05.2019)

SELECT * FROM name_table LIMIT - смещение, количество строк
ALTER TABLE - изменять типы данных столбца (изменение таблицы)

Добавление
ALTER TABLE Author ADD surname TEXT;

Удаление столбца:
ALTER TABLE Author DROP COLUMN surname TEXT;

Изменение столбца:
ALTER TABLE Author MODIFY COLUMN surname VARCHAR(255) NOT NULL;

Добавление первичного ключа:
ALTER TABLE Author ADD PRIMARY KEY имя_столбца;

INSERT INTO Author (`name`, `surname`) VALUES ('Марк', 'Твен')

INSERT INTO Author (`name`, `surname`) VALUES ('Лев', 'Толстой')

INSERT INTO Author (`name`, `surname`) VALUES ('Антон', 'Чехов')

INSERT INTO Author (`name`, `surname`) VALUES ('Александр', 'Пушкин')

Алиасы

SELECT имя_столбца AS alias FROM имя_таблицы;

SELECT имя_столбца FROM имя_таблицы alias;

SELECT concat(name, '', surname) AS author FROM Author;

SELECT price-(price*0.1) AS sale FROM name_table;

1)ON DELETE CASCADE; (удаление всех связанных строк)
2)ON DELETE NULL;
3)ON DELETE NO ACTION; (без действия)

JOIN - запросы


16.05.2019

CREATE TABLE IF NOT EXISTS `mydb`.`comment` (
  `idcomment` INT NOT NULL AUTO_INCREMENT,
  `commentText` MEDIUMTEXT NOT NULL,
  `comment_idcomment` INT NULL,
  PRIMARY KEY (`idcomment`),
  INDEX `fk_comment_comment_idx` (`comment_idcomment` ASC) VISIBLE,
  CONSTRAINT `fk_comment_comment`
    FOREIGN KEY (`comment_idcomment`)
    REFERENCES `mydb`.`comment` (`idcomment`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB

SELECT c1.commentText AS parent, c2.commentText AS child 
FROM comment c1

JOIN comment c2

-- Доступны также Left и Right--

ON c1.idcomment = c2.commen_idcomment;

ФУНКЦИИ

SUM()
AVG()
MIN()
MAX()
COUNT()
DISTINCT()

количество уникальных товаров на складе
SELECT COUNT(*) FROM good;

Уникальные товары в корзине 1
SELECT COUNT(DISTINCT idGood) FROM card_good WHERE idCart = 1;

Сумма заказа по корзине 3

SELECT SUM(cg.amount * g.price) AS res
FROM cart_good cg, good g
WHERE cg.idGood = g.idGood
AND idCart = 3;

Корзины, где сумма заказа больше 1000

SELECT cg.idCart, SUM(cg.amount * g.price) AS res
FROM cart_good cg, good g
WHERE cg.idGood = g.idGood
GROUP BY cg.idCart
HAVING SUM(cg.amount * g.price) > 1000;


1.Товары, которых нет в корзине (например, корзина 1)
2.Средний чек по трем корзинам
3.Максимальный и минимальный чеки


ТРИГГЕРЫ

DELIMITER $$

CREATE TRIGGER trigger_name
	time_of_event type_of_event ON name_table
	FOR EACH ROW
	BEGIN
		trigger_body;
	END $$
DELIMITER ;

time_of_event: BEFORE | AFTER
type_of_event: INSERT | UPDATE | DELETE

CREATE TABLE book_backup (
	id INT  NOT NULL AUTO_INCREMENT PRIMARY KEY,
	rowId INT UNSIGNED NOT NULL,
	title VARCHAR(255) NOT NULL
);

Объекты для БД и что с ними можно делать
			Таблицы (table)
	CREATE TABLE
	DROP TABLE
	ALTER TABLE 
			Индексы (первичные и внешние ключи)
	CREATE 
	DROP
	ALTER
			Триггеры (trigger)
	CREATE TRIGGER
	DROP TRIGGER
			Представления (view)
Таблица, получаемая после какого-то запроса, которая может быть
сохранена, и к которой можно делать
	Создание представления
CREATE VIEW name_of_view AS SELECT name_of_column FROM name_of_table;
	Обращение к представлению
SELECT * FROM book_view;

			Хранимые процедуры (procedure) - не возвращает значение
	Параметры
IN - принимаются и используются
OUT - в них записываются данные, и мы их используем
INOUT - и то, и другое

	Пример

DELITIMER $$

CREATE PROCEDURE getPrice(IN some_data DOUBLE)
BEGIN
	SELECT price-price*some_data FROM book;
END$$
DELIMITER ;

	Вызов IN - процедуры

CALL getPrice(0.7);

	OUT параметры
DELIMITER $$
CREATE PROCEDURE getMaxPriceByAuthor(OUT max_price INT, IN author_name VARCHAR(255))
BEGIN
	SELECT MAX(price) INTO max_price FROM book
	WHERE author = author_name;
END$$
DELIMITER ;

	Вызов OUT - процедуры
CALL getMaxPriceByAuthor(@m, 'Марк Твен');
SELECT @m AS max_price;

			Хранимые функции (function)

DELIMITER $$

CREATE FUNCTION getBookCount() RETURNS INTEGER
BEGIN
	DECLARE val INTEGER;
	SELECT COUNT(*) INTO val FROM book;
	RETURN IFNULL (val, 0);
END$$

DELIMITER ;

	Вызов функции
SELECT getBookCount();






Хроника восхождений в альпинистский клуб


